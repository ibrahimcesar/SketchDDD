import type { ContextData, EntityNode, ValueNode, EnumNode, AggregateNode, ContextMap } from '@/types';

export interface DocumentationOptions {
  includeTableOfContents: boolean;
  includeRelationships: boolean;
  includeContextMaps: boolean;
  format: 'markdown' | 'html';
}

const defaultOptions: DocumentationOptions = {
  includeTableOfContents: true,
  includeRelationships: true,
  includeContextMaps: true,
  format: 'markdown',
};

export function generateDocumentation(
  context: ContextData,
  contextMaps: ContextMap[] = [],
  options: Partial<DocumentationOptions> = {}
): string {
  const opts = { ...defaultOptions, ...options };
  const lines: string[] = [];

  // Header
  lines.push(`# ${context.name}`);
  lines.push('');
  lines.push(`*Generated by SketchDDD on ${new Date().toLocaleDateString()}*`);
  lines.push('');

  const nodeEntries = Object.entries(context.nodes);
  const entities = nodeEntries.filter(([, d]) => d.node.kind === 'entity');
  const valueObjects = nodeEntries.filter(([, d]) => d.node.kind === 'value');
  const enums = nodeEntries.filter(([, d]) => d.node.kind === 'enum');
  const aggregates = nodeEntries.filter(([, d]) => d.node.kind === 'aggregate');

  // Table of Contents
  if (opts.includeTableOfContents) {
    lines.push('## Table of Contents');
    lines.push('');
    if (entities.length > 0) {
      lines.push('- [Entities](#entities)');
      entities.forEach(([, d]) => {
        lines.push(`  - [${d.node.name}](#${slugify(d.node.name)})`);
      });
    }
    if (valueObjects.length > 0) {
      lines.push('- [Value Objects](#value-objects)');
      valueObjects.forEach(([, d]) => {
        lines.push(`  - [${d.node.name}](#${slugify(d.node.name)})`);
      });
    }
    if (enums.length > 0) {
      lines.push('- [Enumerations](#enumerations)');
      enums.forEach(([, d]) => {
        lines.push(`  - [${d.node.name}](#${slugify(d.node.name)})`);
      });
    }
    if (aggregates.length > 0) {
      lines.push('- [Aggregates](#aggregates)');
      aggregates.forEach(([, d]) => {
        lines.push(`  - [${d.node.name}](#${slugify(d.node.name)})`);
      });
    }
    if (opts.includeRelationships && context.morphisms.length > 0) {
      lines.push('- [Relationships](#relationships)');
    }
    if (opts.includeContextMaps && contextMaps.length > 0) {
      lines.push('- [Context Maps](#context-maps)');
    }
    lines.push('');
  }

  // Summary
  lines.push('## Summary');
  lines.push('');
  lines.push('| Category | Count |');
  lines.push('|----------|-------|');
  lines.push(`| Entities | ${entities.length} |`);
  lines.push(`| Value Objects | ${valueObjects.length} |`);
  lines.push(`| Enumerations | ${enums.length} |`);
  lines.push(`| Aggregates | ${aggregates.length} |`);
  lines.push(`| Relationships | ${context.morphisms.length} |`);
  lines.push('');

  // Entities
  if (entities.length > 0) {
    lines.push('## Entities');
    lines.push('');
    lines.push('Entities are objects with a unique identity that persists over time.');
    lines.push('');

    entities.forEach(([id, data]) => {
      const entity = data.node as EntityNode;
      lines.push(`### ${entity.name}`);
      lines.push('');
      lines.push('**Type:** Entity');
      lines.push('');

      if (entity.fields.length > 0) {
        lines.push('#### Fields');
        lines.push('');
        lines.push('| Name | Type | Required |');
        lines.push('|------|------|----------|');
        lines.push('| id | UUID | Yes |');
        entity.fields.forEach(field => {
          lines.push(`| ${field.name} | ${field.type} | ${field.optional ? 'No' : 'Yes'} |`);
        });
        lines.push('');
      }

      // Relationships for this entity
      const outgoing = context.morphisms.filter(m => m.sourceId === id);
      const incoming = context.morphisms.filter(m => m.targetId === id);

      if (outgoing.length > 0 || incoming.length > 0) {
        lines.push('#### Relationships');
        lines.push('');
        outgoing.forEach(m => {
          const target = context.nodes[m.targetId]?.node;
          if (target) {
            lines.push(`- **${m.name}** → ${target.name} (${m.cardinality})`);
          }
        });
        incoming.forEach(m => {
          const source = context.nodes[m.sourceId]?.node;
          if (source) {
            lines.push(`- ← **${m.name}** from ${source.name} (${m.cardinality})`);
          }
        });
        lines.push('');
      }
    });
  }

  // Value Objects
  if (valueObjects.length > 0) {
    lines.push('## Value Objects');
    lines.push('');
    lines.push('Value Objects are immutable types that are defined by their attributes rather than identity.');
    lines.push('');

    valueObjects.forEach(([, data]) => {
      const value = data.node as ValueNode;
      lines.push(`### ${value.name}`);
      lines.push('');
      lines.push('**Type:** Value Object');
      lines.push('');

      if (value.fields.length > 0) {
        lines.push('#### Fields');
        lines.push('');
        lines.push('| Name | Type | Required |');
        lines.push('|------|------|----------|');
        value.fields.forEach(field => {
          lines.push(`| ${field.name} | ${field.type} | ${field.optional ? 'No' : 'Yes'} |`);
        });
        lines.push('');
      }
    });
  }

  // Enums
  if (enums.length > 0) {
    lines.push('## Enumerations');
    lines.push('');
    lines.push('Enumerations represent a fixed set of possible values.');
    lines.push('');

    enums.forEach(([, data]) => {
      const enumNode = data.node as EnumNode;
      lines.push(`### ${enumNode.name}`);
      lines.push('');
      lines.push('**Type:** Enumeration');
      lines.push('');
      lines.push('#### Variants');
      lines.push('');
      enumNode.variants.forEach(variant => {
        lines.push(`- \`${variant.name}\`${variant.payload ? ` (payload: ${variant.payload})` : ''}`);
      });
      lines.push('');
    });
  }

  // Aggregates
  if (aggregates.length > 0) {
    lines.push('## Aggregates');
    lines.push('');
    lines.push('Aggregates are clusters of entities and value objects that are treated as a single unit for data changes.');
    lines.push('');

    aggregates.forEach(([, data]) => {
      const aggregate = data.node as AggregateNode;
      const rootNode = context.nodes[aggregate.rootId]?.node;

      lines.push(`### ${aggregate.name}`);
      lines.push('');
      lines.push('**Type:** Aggregate');
      if (rootNode) {
        lines.push(`**Root Entity:** ${rootNode.name}`);
      }
      lines.push('');

      if (aggregate.memberIds.length > 0) {
        lines.push('#### Members');
        lines.push('');
        aggregate.memberIds.forEach(memberId => {
          const member = context.nodes[memberId]?.node;
          if (member) {
            lines.push(`- ${member.name}`);
          }
        });
        lines.push('');
      }

      if (aggregate.invariants.length > 0) {
        lines.push('#### Invariants');
        lines.push('');
        aggregate.invariants.forEach((inv, i) => {
          lines.push(`${i + 1}. ${inv}`);
        });
        lines.push('');
      }
    });
  }

  // Relationships
  if (opts.includeRelationships && context.morphisms.length > 0) {
    lines.push('## Relationships');
    lines.push('');
    lines.push('| Source | Relationship | Target | Cardinality |');
    lines.push('|--------|--------------|--------|-------------|');
    context.morphisms.forEach(m => {
      const source = context.nodes[m.sourceId]?.node;
      const target = context.nodes[m.targetId]?.node;
      if (source && target) {
        lines.push(`| ${source.name} | ${m.name} | ${target.name} | ${m.cardinality} |`);
      }
    });
    lines.push('');
  }

  // Context Maps
  if (opts.includeContextMaps && contextMaps.length > 0) {
    const relevantMaps = contextMaps.filter(
      m => m.sourceContextId === context.id || m.targetContextId === context.id
    );

    if (relevantMaps.length > 0) {
      lines.push('## Context Maps');
      lines.push('');
      lines.push('Integration patterns with other bounded contexts.');
      lines.push('');

      relevantMaps.forEach(map => {
        lines.push(`### ${map.name}`);
        lines.push('');
        lines.push(`**Pattern:** ${formatPattern(map.pattern)}`);
        lines.push(`**Direction:** ${map.sourceContextId === context.id ? 'Upstream' : 'Downstream'}`);
        lines.push('');

        if (map.mappings.length > 0) {
          lines.push('#### Object Mappings');
          lines.push('');
          lines.push('| Source | Target |');
          lines.push('|--------|--------|');
          map.mappings.forEach(mapping => {
            lines.push(`| ${mapping.sourceId} | ${mapping.targetId} |`);
          });
          lines.push('');
        }
      });
    }
  }

  return lines.join('\n');
}

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');
}

function formatPattern(pattern: string): string {
  const patterns: Record<string, string> = {
    SharedKernel: 'Shared Kernel',
    CustomerSupplier: 'Customer-Supplier',
    Conformist: 'Conformist',
    AntiCorruptionLayer: 'Anti-Corruption Layer',
    OpenHostService: 'Open Host Service',
    PublishedLanguage: 'Published Language',
    Partnership: 'Partnership',
    SeparateWays: 'Separate Ways',
  };
  return patterns[pattern] || pattern;
}

//! Clojure code generation for SketchDDD domain models.
//!
//! Generates idiomatic Clojure code from a bounded context:
//! - Entities as records with spec validation
//! - Value objects as records (immutable by default)
//! - Aggregates with validation functions
//! - Keywords for enums
//! - clojure.spec for validation

use crate::CodegenError;
use sketchddd_core::sketch::{ColimitCocone, LimitCone, Morphism, ObjectId};
use sketchddd_core::BoundedContext;
use std::collections::{HashMap, HashSet};

/// Configuration options for Clojure code generation.
#[derive(Debug, Clone)]
pub struct ClojureConfig {
    /// Namespace (defaults to context name in kebab-case)
    pub namespace: Option<String>,
    /// Whether to generate clojure.spec definitions
    pub use_spec: bool,
    /// Whether to generate malli schemas instead of spec
    pub use_malli: bool,
    /// Whether to generate constructor functions
    pub generate_constructors: bool,
    /// Whether to generate validation functions
    pub generate_validation: bool,
}

impl Default for ClojureConfig {
    fn default() -> Self {
        Self {
            namespace: None,
            use_spec: true,
            use_malli: false,
            generate_constructors: true,
            generate_validation: true,
        }
    }
}

/// Generate Clojure code from a bounded context with default configuration.
pub fn generate(context: &BoundedContext) -> Result<String, CodegenError> {
    generate_with_config(context, &ClojureConfig::default())
}

/// Generate Clojure code from a bounded context with custom configuration.
pub fn generate_with_config(
    context: &BoundedContext,
    config: &ClojureConfig,
) -> Result<String, CodegenError> {
    let mut gen = ClojureGenerator::new(context, config);
    gen.generate()
}

/// Internal generator state.
struct ClojureGenerator<'a> {
    context: &'a BoundedContext,
    config: &'a ClojureConfig,
    output: String,
    entity_ids: HashSet<ObjectId>,
    value_object_ids: HashSet<ObjectId>,
    aggregate_roots: HashSet<ObjectId>,
    object_names: HashMap<ObjectId, String>,
    object_morphisms: HashMap<ObjectId, Vec<&'a Morphism>>,
}

impl<'a> ClojureGenerator<'a> {
    fn new(context: &'a BoundedContext, config: &'a ClojureConfig) -> Self {
        let entity_ids: HashSet<_> = context.entities().iter().copied().collect();
        let value_object_ids: HashSet<_> = context.value_objects().iter().copied().collect();
        let aggregate_roots: HashSet<_> = context.aggregate_roots().iter().copied().collect();

        let object_names: HashMap<_, _> = context
            .graph()
            .objects()
            .map(|o| (o.id, o.name.clone()))
            .collect();

        let mut object_morphisms: HashMap<ObjectId, Vec<&Morphism>> = HashMap::new();
        for morphism in context.graph().morphisms() {
            if !morphism.is_identity {
                object_morphisms
                    .entry(morphism.source)
                    .or_default()
                    .push(morphism);
            }
        }

        Self {
            context,
            config,
            output: String::new(),
            entity_ids,
            value_object_ids,
            aggregate_roots,
            object_names,
            object_morphisms,
        }
    }

    fn generate(&mut self) -> Result<String, CodegenError> {
        self.write_header();
        self.write_requires();
        self.write_id_generators();
        self.write_entities();
        self.write_value_objects();
        self.write_enums();
        self.write_aggregates();

        Ok(std::mem::take(&mut self.output))
    }

    fn write_header(&mut self) {
        let ns = self
            .config
            .namespace
            .clone()
            .unwrap_or_else(|| to_kebab_case(self.context.name()));

        self.output.push_str(&format!(
            r#";;; Generated from `{}` bounded context.
;;;
;;; This file was automatically generated by SketchDDD.
;;; DO NOT EDIT - changes will be overwritten.
;;;
;;; To regenerate: sketchddd codegen <model>.sddd --target clojure

(ns {}
"#,
            self.context.name(),
            ns
        ));
    }

    fn write_requires(&mut self) {
        self.output.push_str("  (:require\n");

        if self.config.use_spec {
            self.output.push_str("    [clojure.spec.alpha :as s]\n");
        }

        if self.config.use_malli {
            self.output.push_str("    [malli.core :as m]\n");
            self.output.push_str("    [malli.error :as me]\n");
        }

        self.output.push_str("    [clojure.string :as str]))\n\n");
    }

    fn write_id_generators(&mut self) {
        if self.entity_ids.is_empty() {
            return;
        }

        self.output.push_str(";; =============================================================\n");
        self.output.push_str(";; ID Generation\n");
        self.output.push_str(";; =============================================================\n\n");

        self.output.push_str(
            r#"(defn generate-uuid
  "Generate a new random UUID string."
  []
  (str (java.util.UUID/randomUUID)))

"#,
        );

        for entity_id in self.context.entities() {
            if let Some(entity) = self.context.graph().get_object(*entity_id) {
                let kebab_name = to_kebab_case(&entity.name);
                self.output.push_str(&format!(
                    r#"(defn {kebab_name}-id
  "Create a new {name} ID."
  ([] ({kebab_name}-id (generate-uuid)))
  ([id] {{:type :{kebab_name}-id :value id}}))

"#,
                    name = entity.name
                ));

                // Spec for ID
                if self.config.use_spec {
                    self.output.push_str(&format!(
                        r#"(s/def ::{kebab_name}-id
  (s/keys :req-un [::type ::value]))

"#
                    ));
                }
            }
        }
    }

    fn write_entities(&mut self) {
        if self.entity_ids.is_empty() {
            return;
        }

        self.output.push_str(";; =============================================================\n");
        self.output.push_str(";; Entities\n");
        self.output.push_str(";; =============================================================\n\n");

        for entity_id in self.context.entities() {
            if let Some(entity) = self.context.graph().get_object(*entity_id) {
                self.write_entity(&entity.name, *entity_id);
            }
        }
    }

    fn write_entity(&mut self, name: &str, object_id: ObjectId) {
        let kebab_name = to_kebab_case(name);
        let is_aggregate_root = self.aggregate_roots.contains(&object_id);

        // Record definition
        self.output.push_str(&format!(
            r#"(defrecord {name} [id"#
        ));

        // Add fields from morphisms
        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = to_kebab_case(&morphism.name);
                self.output.push_str(&format!(" {field_name}"));
            }
        }

        self.output.push_str("])\n\n");

        // Docstring comment
        if is_aggregate_root {
            self.output.push_str(&format!(";; Entity: {} (Aggregate Root)\n", name));
        } else {
            self.output.push_str(&format!(";; Entity: {}\n", name));
        }
        self.output.push_str(";; An entity has a unique identity that persists through state changes.\n\n");

        // Constructor function
        if self.config.generate_constructors {
            self.output.push_str(&format!(
                r#"(defn create-{kebab_name}
  "Create a new {name} entity with a generated ID."
  ["#
            ));

            // Parameters (without id)
            if let Some(morphisms) = self.object_morphisms.get(&object_id) {
                let params: Vec<String> = morphisms
                    .iter()
                    .map(|m| to_kebab_case(&m.name))
                    .collect();
                self.output.push_str(&params.join(" "));
            }

            self.output.push_str("]\n");
            self.output.push_str(&format!("  (map->{name} {{\n"));
            self.output.push_str(&format!("    :id ({kebab_name}-id)\n"));

            if let Some(morphisms) = self.object_morphisms.get(&object_id) {
                for morphism in morphisms {
                    let field_name = to_kebab_case(&morphism.name);
                    self.output.push_str(&format!("    :{field_name} {field_name}\n"));
                }
            }

            self.output.push_str("  }))\n\n");
        }

        // Spec definition
        if self.config.use_spec {
            self.output.push_str(&format!("(s/def ::{kebab_name}\n"));
            self.output.push_str(&format!("  (s/keys :req-un [::{kebab_name}-id"));

            if let Some(morphisms) = self.object_morphisms.get(&object_id) {
                for morphism in morphisms {
                    let field_name = to_kebab_case(&morphism.name);
                    self.output.push_str(&format!(" ::{field_name}"));
                }
            }

            self.output.push_str("]))\n\n");
        }
    }

    fn write_value_objects(&mut self) {
        if self.value_object_ids.is_empty() {
            return;
        }

        self.output.push_str(";; =============================================================\n");
        self.output.push_str(";; Value Objects\n");
        self.output.push_str(";; =============================================================\n\n");

        for vo_id in self.context.value_objects() {
            if let Some(vo) = self.context.graph().get_object(*vo_id) {
                self.write_value_object(&vo.name, *vo_id);
            }
        }
    }

    fn write_value_object(&mut self, name: &str, object_id: ObjectId) {
        let kebab_name = to_kebab_case(name);

        // Record definition
        self.output.push_str(&format!(r#"(defrecord {name} ["#));

        let morphisms = self.object_morphisms.get(&object_id);
        if let Some(morphisms) = morphisms {
            let fields: Vec<String> = morphisms
                .iter()
                .map(|m| to_kebab_case(&m.name))
                .collect();
            self.output.push_str(&fields.join(" "));
        }

        self.output.push_str("])\n\n");

        // Docstring comment
        self.output.push_str(&format!(";; Value Object: {}\n", name));
        self.output.push_str(";; A value object is defined by its attributes, not identity.\n");
        self.output.push_str(";; Two value objects with the same attributes are considered equal.\n\n");

        // Constructor function
        if self.config.generate_constructors {
            self.output.push_str(&format!(
                r#"(defn make-{kebab_name}
  "Create a new {name} value object."
  ["#
            ));

            if let Some(morphisms) = morphisms {
                let params: Vec<String> = morphisms
                    .iter()
                    .map(|m| to_kebab_case(&m.name))
                    .collect();
                self.output.push_str(&params.join(" "));
            }

            self.output.push_str("]\n");
            self.output.push_str(&format!("  (map->{name} {{"));

            if let Some(morphisms) = morphisms {
                let assignments: Vec<String> = morphisms
                    .iter()
                    .map(|m| {
                        let field_name = to_kebab_case(&m.name);
                        format!(":{} {}", field_name, field_name)
                    })
                    .collect();
                self.output.push_str(&assignments.join(" "));
            }

            self.output.push_str("}))\n\n");
        }

        // Spec definition
        if self.config.use_spec {
            self.output.push_str(&format!("(s/def ::{kebab_name}\n"));
            self.output.push_str("  (s/keys :req-un [");

            if let Some(morphisms) = morphisms {
                let specs: Vec<String> = morphisms
                    .iter()
                    .map(|m| format!("::{}", to_kebab_case(&m.name)))
                    .collect();
                self.output.push_str(&specs.join(" "));
            }

            self.output.push_str("]))\n\n");
        }
    }

    fn write_enums(&mut self) {
        let colimits = &self.context.sketch().colimits;
        if colimits.is_empty() {
            return;
        }

        self.output.push_str(";; =============================================================\n");
        self.output.push_str(";; Enumerations (Sum Types)\n");
        self.output.push_str(";; =============================================================\n\n");

        for colimit in colimits {
            self.write_enum(colimit);
        }
    }

    fn write_enum(&mut self, colimit: &ColimitCocone) {
        let kebab_name = to_kebab_case(&colimit.name);
        let is_simple_enum = colimit.injections.iter().all(|i| i.source == colimit.apex);

        if is_simple_enum {
            // Simple enum as set of keywords
            self.output.push_str(&format!(";; Enumeration: {}\n", colimit.name));
            self.output.push_str(";; A simple enumeration of possible values.\n\n");

            self.output.push_str(&format!("(def {kebab_name}-values\n"));
            self.output.push_str("  #{");

            let variants: Vec<String> = colimit
                .injections
                .iter()
                .map(|i| format!(":{}", to_kebab_case(&i.name)))
                .collect();
            self.output.push_str(&variants.join(" "));

            self.output.push_str("})\n\n");

            // Spec for enum
            if self.config.use_spec {
                self.output.push_str(&format!(
                    "(s/def ::{kebab_name} {kebab_name}-values)\n\n"
                ));
            }

            // Predicate functions
            for injection in &colimit.injections {
                let variant_kebab = to_kebab_case(&injection.name);
                self.output.push_str(&format!(
                    r#"(defn {variant_kebab}?
  "Check if value is :{variant_kebab}."
  [v]
  (= v :{variant_kebab}))

"#
                ));
            }
        } else {
            // Sum type with payloads using tagged maps
            self.output.push_str(&format!(";; Sum Type: {}\n", colimit.name));
            self.output.push_str(";; A tagged union representing one of several possible variants.\n\n");

            // Constructor functions for each variant
            for injection in &colimit.injections {
                let variant_kebab = to_kebab_case(&injection.name);
                let variant_type = self
                    .object_names
                    .get(&injection.source)
                    .cloned()
                    .unwrap_or_else(|| "any".to_string());
                let variant_type_kebab = to_kebab_case(&variant_type);

                self.output.push_str(&format!(
                    r#"(defn {kebab_name}-{variant_kebab}
  "Create a {name} with {variant} variant."
  [{variant_type_kebab}]
  {{:type :{kebab_name}
   :variant :{variant_kebab}
   :value {variant_type_kebab}}})

"#,
                    name = colimit.name,
                    variant = injection.name
                ));
            }

            // Spec for sum type
            if self.config.use_spec {
                self.output.push_str(&format!(
                    r#"(s/def ::{kebab_name}
  (s/keys :req-un [::type ::variant ::value]))

"#
                ));
            }

            // Predicate functions
            for injection in &colimit.injections {
                let variant_kebab = to_kebab_case(&injection.name);
                self.output.push_str(&format!(
                    r#"(defn {kebab_name}-{variant_kebab}?
  "Check if value is the {variant} variant."
  [v]
  (and (map? v)
       (= (:type v) :{kebab_name})
       (= (:variant v) :{variant_kebab})))

"#,
                    variant = injection.name
                ));
            }
        }
    }

    fn write_aggregates(&mut self) {
        let limits: Vec<_> = self
            .context
            .sketch()
            .limits
            .iter()
            .filter(|l| l.is_aggregate)
            .collect();

        if limits.is_empty() || !self.config.generate_validation {
            return;
        }

        self.output.push_str(";; =============================================================\n");
        self.output.push_str(";; Aggregate Validation\n");
        self.output.push_str(";; =============================================================\n\n");

        self.write_validation_error();

        for limit in limits {
            self.write_aggregate_validation(limit);
        }
    }

    fn write_validation_error(&mut self) {
        self.output.push_str(
            r#"(defn validation-error
  "Create a validation error."
  [invariant message]
  {:invariant invariant :message message})

(defn validation-success
  "Create a successful validation result."
  [value]
  {:success true :value value :errors []})

(defn validation-failure
  "Create a failed validation result."
  [errors]
  {:success false :value nil :errors errors})

(defn validation-success?
  "Check if validation result is successful."
  [result]
  (:success result))

"#,
        );
    }

    fn write_aggregate_validation(&mut self, limit: &LimitCone) {
        let root_id = match limit.root {
            Some(id) => id,
            None => return,
        };

        let root_name = self
            .object_names
            .get(&root_id)
            .cloned()
            .unwrap_or_else(|| "Unknown".to_string());

        let root_kebab = to_kebab_case(&root_name);

        self.output.push_str(&format!(";; Aggregate: {}\n", limit.name));
        self.output.push_str(&format!(";; Root: {}\n\n", root_name));

        self.output.push_str(&format!(
            r#"(defn validate-{root_kebab}
  "Validate {root_name} aggregate invariants.

  Call this function after making changes to ensure the aggregate
  is in a valid state."
  [entity]
  (let [errors (atom [])]
    ;; TODO: Add invariant validation logic based on model equations
    ;;
    ;; Example invariant:
    ;; (when (not= (:total-price entity)
    ;;             (reduce + (map :price (:items entity))))
    ;;   (swap! errors conj (validation-error
    ;;                        "total-price"
    ;;                        "total-price must equal sum of item prices")))

    (if (empty? @errors)
      (validation-success entity)
      (validation-failure @errors))))

(defn validate-{root_kebab}!
  "Validate and return entity, throwing on failure."
  [entity]
  (let [result (validate-{root_kebab} entity)]
    (if (validation-success? result)
      (:value result)
      (throw (ex-info "Validation failed"
                      {{:errors (:errors result)}})))))

"#
        ));
    }
}

/// Convert PascalCase to kebab-case.
fn to_kebab_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len() + 4);
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('-');
            }
            result.push(c.to_ascii_lowercase());
        } else if c == '_' {
            result.push('-');
        } else {
            result.push(c);
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_kebab_case() {
        assert_eq!(to_kebab_case("Customer"), "customer");
        assert_eq!(to_kebab_case("OrderId"), "order-id");
        assert_eq!(to_kebab_case("LineItem"), "line-item");
        assert_eq!(to_kebab_case("placed_by"), "placed-by");
    }

    #[test]
    fn test_generate_empty_context() {
        let context = BoundedContext::new("Test");
        let result = generate(&context).unwrap();

        assert!(result.contains("Generated from `Test` bounded context"));
        assert!(result.contains("(ns test"));
        assert!(result.contains("[clojure.spec.alpha :as s]"));
    }

    #[test]
    fn test_generate_entity() {
        let mut context = BoundedContext::new("Commerce");
        let _customer = context.add_entity("Customer");

        let result = generate(&context).unwrap();

        // Should have ID generator
        assert!(result.contains("(defn customer-id"));
        assert!(result.contains("(generate-uuid)"));

        // Should have record
        assert!(result.contains("(defrecord Customer [id"));

        // Should have constructor
        assert!(result.contains("(defn create-customer"));

        // Should have spec
        assert!(result.contains("(s/def ::customer"));
    }

    #[test]
    fn test_generate_entity_with_morphisms() {
        let mut context = BoundedContext::new("Commerce");
        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");

        context.sketch_mut().graph.add_morphism("placed_by", order, customer);

        let result = generate(&context).unwrap();

        assert!(result.contains("(defrecord Order [id placed-by]"));
        assert!(result.contains(":placed-by placed-by"));
    }

    #[test]
    fn test_generate_value_object() {
        let mut context = BoundedContext::new("Commerce");
        let _money = context.add_value_object("Money");

        let result = generate(&context).unwrap();

        assert!(result.contains(";; Value Objects"));
        assert!(result.contains("(defrecord Money ["));
        assert!(result.contains("(defn make-money"));
    }

    #[test]
    fn test_generate_simple_enum() {
        let mut context = BoundedContext::new("Commerce");
        let _status = context.add_enum(
            "OrderStatus",
            vec!["Pending".into(), "Confirmed".into(), "Shipped".into()],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("(def order-status-values"));
        assert!(result.contains(":pending"));
        assert!(result.contains(":confirmed"));
        assert!(result.contains(":shipped"));
        assert!(result.contains("(defn pending?"));
    }

    #[test]
    fn test_generate_aggregate() {
        let mut context = BoundedContext::new("Commerce");
        let order = context.add_entity("Order");
        let line_item = context.add_entity("LineItem");

        context.define_aggregate_with_members("OrderAggregate", order, &[line_item]);

        let result = generate(&context).unwrap();

        assert!(result.contains(";; Aggregate Validation"));
        assert!(result.contains("(defn validation-error"));
        assert!(result.contains("(defn validate-order"));
        assert!(result.contains("(defn validate-order!"));
    }

    #[test]
    fn test_generate_sum_type() {
        let mut context = BoundedContext::new("Payments");

        let transaction_id = context.sketch_mut().add_object("TransactionId");
        let error_code = context.sketch_mut().add_object("ErrorCode");

        let _result = context.add_sum_type(
            "PaymentResult",
            vec![
                ("Success".into(), transaction_id),
                ("Failed".into(), error_code),
            ],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("(defn payment-result-success"));
        assert!(result.contains("(defn payment-result-failed"));
        assert!(result.contains("(defn payment-result-success?"));
        assert!(result.contains("(defn payment-result-failed?"));
    }

    #[test]
    fn test_config_no_spec() {
        let mut context = BoundedContext::new("Test");
        let _customer = context.add_entity("Customer");

        let config = ClojureConfig {
            use_spec: false,
            ..Default::default()
        };

        let result = generate_with_config(&context, &config).unwrap();

        assert!(!result.contains("[clojure.spec.alpha :as s]"));
        assert!(!result.contains("(s/def"));
    }
}

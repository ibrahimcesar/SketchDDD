//! Haskell code generation for SketchDDD domain models.
//!
//! Generates idiomatic Haskell code from a bounded context:
//! - Entities as data types with newtype IDs
//! - Value objects as data types with Eq instances
//! - Aggregates with validation using Either
//! - Sum types using ADTs (Algebraic Data Types)
//! - Aeson instances for JSON serialization
//! - QuickCheck Arbitrary instances (optional)

use crate::CodegenError;
use sketchddd_core::sketch::{ColimitCocone, LimitCone, Morphism, ObjectId};
use sketchddd_core::BoundedContext;
use std::collections::{HashMap, HashSet};

/// Configuration options for Haskell code generation.
#[derive(Debug, Clone)]
pub struct HaskellConfig {
    /// Module name (defaults to context name in PascalCase)
    pub module_name: Option<String>,
    /// Whether to derive Generic instances
    pub derive_generic: bool,
    /// Whether to generate Aeson (JSON) instances
    pub use_aeson: bool,
    /// Whether to generate QuickCheck Arbitrary instances
    pub use_quickcheck: bool,
    /// Whether to generate validation functions
    pub generate_validation: bool,
    /// Whether to use strict fields
    pub strict_fields: bool,
}

impl Default for HaskellConfig {
    fn default() -> Self {
        Self {
            module_name: None,
            derive_generic: true,
            use_aeson: true,
            use_quickcheck: false,
            generate_validation: true,
            strict_fields: true,
        }
    }
}

/// Generate Haskell code from a bounded context with default configuration.
pub fn generate(context: &BoundedContext) -> Result<String, CodegenError> {
    generate_with_config(context, &HaskellConfig::default())
}

/// Generate Haskell code from a bounded context with custom configuration.
pub fn generate_with_config(
    context: &BoundedContext,
    config: &HaskellConfig,
) -> Result<String, CodegenError> {
    let mut gen = HaskellGenerator::new(context, config);
    gen.generate()
}

/// Internal generator state.
struct HaskellGenerator<'a> {
    context: &'a BoundedContext,
    config: &'a HaskellConfig,
    output: String,
    entity_ids: HashSet<ObjectId>,
    value_object_ids: HashSet<ObjectId>,
    aggregate_roots: HashSet<ObjectId>,
    object_names: HashMap<ObjectId, String>,
    object_morphisms: HashMap<ObjectId, Vec<&'a Morphism>>,
}

impl<'a> HaskellGenerator<'a> {
    fn new(context: &'a BoundedContext, config: &'a HaskellConfig) -> Self {
        let entity_ids: HashSet<_> = context.entities().iter().copied().collect();
        let value_object_ids: HashSet<_> = context.value_objects().iter().copied().collect();
        let aggregate_roots: HashSet<_> = context.aggregate_roots().iter().copied().collect();

        let object_names: HashMap<_, _> = context
            .graph()
            .objects()
            .map(|o| (o.id, o.name.clone()))
            .collect();

        let mut object_morphisms: HashMap<ObjectId, Vec<&Morphism>> = HashMap::new();
        for morphism in context.graph().morphisms() {
            if !morphism.is_identity {
                object_morphisms
                    .entry(morphism.source)
                    .or_default()
                    .push(morphism);
            }
        }

        Self {
            context,
            config,
            output: String::new(),
            entity_ids,
            value_object_ids,
            aggregate_roots,
            object_names,
            object_morphisms,
        }
    }

    fn generate(&mut self) -> Result<String, CodegenError> {
        self.write_header();
        self.write_imports();
        self.write_entities();
        self.write_value_objects();
        self.write_enums();
        self.write_aggregates();

        Ok(std::mem::take(&mut self.output))
    }

    fn write_header(&mut self) {
        let module_name = self
            .config
            .module_name
            .clone()
            .unwrap_or_else(|| self.context.name().to_string());

        self.output.push_str(&format!(
            r#"{{-# LANGUAGE DeriveGeneric #-}}
{{-# LANGUAGE DerivingStrategies #-}}
{{-# LANGUAGE GeneralizedNewtypeDeriving #-}}
{{-# LANGUAGE OverloadedStrings #-}}
{{-# LANGUAGE StrictData #-}}

{{-|
Module      : {}
Description : Generated from `{}` bounded context
Stability   : experimental

This file was automatically generated by SketchDDD.
DO NOT EDIT - changes will be overwritten.

To regenerate: @sketchddd codegen model.sddd --target haskell@
-}}
module {} where

"#,
            module_name,
            self.context.name(),
            module_name
        ));
    }

    fn write_imports(&mut self) {
        self.output.push_str("import Data.Text (Text)\n");
        self.output.push_str("import Data.UUID (UUID)\n");
        self.output.push_str("import qualified Data.UUID as UUID\n");
        self.output.push_str("import qualified Data.UUID.V4 as UUID\n");

        if self.config.derive_generic {
            self.output.push_str("import GHC.Generics (Generic)\n");
        }

        if self.config.use_aeson {
            self.output.push_str("import Data.Aeson (ToJSON, FromJSON)\n");
        }

        if self.config.use_quickcheck {
            self.output.push_str("import Test.QuickCheck (Arbitrary(..))\n");
        }

        self.output.push_str("\n");
    }

    fn write_entities(&mut self) {
        if self.entity_ids.is_empty() {
            return;
        }

        self.output.push_str("-- =============================================================\n");
        self.output.push_str("-- Entities\n");
        self.output.push_str("-- =============================================================\n\n");

        for entity_id in self.context.entities() {
            if let Some(entity) = self.context.graph().get_object(*entity_id) {
                self.write_entity_id_type(&entity.name);
                self.write_entity_data_type(&entity.name, *entity_id);
            }
        }
    }

    fn write_entity_id_type(&mut self, name: &str) {
        let derives = self.format_derives(&["Eq", "Ord", "Show"]);

        self.output.push_str(&format!(
            r#"-- | Unique identifier for '{name}'.
newtype {name}Id = {name}Id {{ un{name}Id :: UUID }}
  deriving stock ({derives})
"#
        ));

        if self.config.derive_generic {
            self.output.push_str("  deriving stock (Generic)\n");
        }

        if self.config.use_aeson {
            self.output.push_str("  deriving newtype (ToJSON, FromJSON)\n");
        }

        self.output.push_str("\n");

        // Smart constructor
        self.output.push_str(&format!(
            r#"-- | Create a new random '{name}Id'.
new{name}Id :: IO {name}Id
new{name}Id = {name}Id <$> UUID.nextRandom

-- | Create '{name}Id' from a UUID.
mk{name}Id :: UUID -> {name}Id
mk{name}Id = {name}Id

"#
        ));
    }

    fn write_entity_data_type(&mut self, name: &str, object_id: ObjectId) {
        let is_aggregate_root = self.aggregate_roots.contains(&object_id);
        let root_note = if is_aggregate_root {
            " (Aggregate Root)"
        } else {
            ""
        };

        let bang = if self.config.strict_fields { "!" } else { "" };
        let field_prefix = to_camel_case(name);

        self.output.push_str(&format!(
            r#"-- | Entity: {name}{root_note}
--
-- An entity has a unique identity that persists through state changes.
data {name} = {name}
  {{ {field_prefix}Id :: {bang}{name}Id
"#
        ));

        // Add fields from morphisms
        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = format!("{}{}", field_prefix, capitalize_first(&morphism.name));
                let field_type = self.haskell_type_for_target(morphism.target);

                if let Some(desc) = &morphism.description {
                    self.output.push_str(&format!("    -- ^ {}\n", desc));
                }
                self.output.push_str(&format!("  , {} :: {}{}\n", field_name, bang, field_type));
            }
        }

        self.output.push_str("  }");

        // Deriving clause
        let derives = self.format_derives(&["Eq", "Show"]);
        self.output.push_str(&format!("\n  deriving stock ({}", derives));

        if self.config.derive_generic {
            self.output.push_str(", Generic");
        }

        self.output.push_str(")\n");

        if self.config.use_aeson {
            self.output.push_str(&format!(
                "\ninstance ToJSON {name}\ninstance FromJSON {name}\n"
            ));
        }

        self.output.push_str("\n");

        // Smart constructor
        self.write_entity_constructor(name, object_id);
    }

    fn write_entity_constructor(&mut self, name: &str, object_id: ObjectId) {
        let field_prefix = to_camel_case(name);

        self.output.push_str(&format!(
            r#"-- | Create a new '{name}' with a generated ID.
create{name} :: "#
        ));

        // Type signature parameters
        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_type = self.haskell_type_for_target(morphism.target);
                self.output.push_str(&format!("{} -> ", field_type));
            }
        }

        self.output.push_str(&format!("IO {name}\n"));
        self.output.push_str(&format!("create{name} "));

        // Parameter names
        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            let params: Vec<String> = morphisms
                .iter()
                .map(|m| to_camel_case(&m.name))
                .collect();
            self.output.push_str(&params.join(" "));
        }

        self.output.push_str(" = do\n");
        self.output.push_str(&format!("  entityId <- new{}Id\n", name));
        self.output.push_str(&format!("  pure {name}\n"));
        self.output.push_str(&format!("    {{ {}Id = entityId\n", field_prefix));

        if let Some(morphisms) = self.object_morphisms.get(&object_id) {
            for morphism in morphisms {
                let field_name = format!("{}{}", field_prefix, capitalize_first(&morphism.name));
                let param_name = to_camel_case(&morphism.name);
                self.output.push_str(&format!("    , {} = {}\n", field_name, param_name));
            }
        }

        self.output.push_str("    }\n\n");
    }

    fn write_value_objects(&mut self) {
        if self.value_object_ids.is_empty() {
            return;
        }

        self.output.push_str("-- =============================================================\n");
        self.output.push_str("-- Value Objects\n");
        self.output.push_str("-- =============================================================\n\n");

        for vo_id in self.context.value_objects() {
            if let Some(vo) = self.context.graph().get_object(*vo_id) {
                self.write_value_object(&vo.name, *vo_id);
            }
        }
    }

    fn write_value_object(&mut self, name: &str, object_id: ObjectId) {
        let bang = if self.config.strict_fields { "!" } else { "" };
        let field_prefix = to_camel_case(name);

        self.output.push_str(&format!(
            r#"-- | Value Object: {name}
--
-- A value object is defined by its attributes, not identity.
-- Two value objects with the same attributes are considered equal.
data {name} = {name}
  {{ "#
        ));

        let morphisms = self.object_morphisms.get(&object_id);
        if let Some(morphisms) = morphisms {
            let fields: Vec<String> = morphisms
                .iter()
                .map(|m| {
                    let field_name = format!("{}{}", field_prefix, capitalize_first(&m.name));
                    let field_type = self.haskell_type_for_target(m.target);
                    format!("{} :: {}{}", field_name, bang, field_type)
                })
                .collect();
            self.output.push_str(&fields.join("\n  , "));
        }

        self.output.push_str("\n  }");

        // Deriving clause
        let derives = self.format_derives(&["Eq", "Show"]);
        self.output.push_str(&format!("\n  deriving stock ({}", derives));

        if self.config.derive_generic {
            self.output.push_str(", Generic");
        }

        self.output.push_str(")\n");

        if self.config.use_aeson {
            self.output.push_str(&format!(
                "\ninstance ToJSON {name}\ninstance FromJSON {name}\n"
            ));
        }

        self.output.push_str("\n");
    }

    fn write_enums(&mut self) {
        let colimits = &self.context.sketch().colimits;
        if colimits.is_empty() {
            return;
        }

        self.output.push_str("-- =============================================================\n");
        self.output.push_str("-- Enumerations (Sum Types)\n");
        self.output.push_str("-- =============================================================\n\n");

        for colimit in colimits {
            self.write_enum(colimit);
        }
    }

    fn write_enum(&mut self, colimit: &ColimitCocone) {
        let is_simple_enum = colimit.injections.iter().all(|i| i.source == colimit.apex);

        self.output.push_str(&format!("-- | {}\n", colimit.name));

        if is_simple_enum {
            self.output.push_str("--\n-- A simple enumeration of possible values.\n");
            self.output.push_str(&format!("data {} =\n", colimit.name));

            for (i, injection) in colimit.injections.iter().enumerate() {
                if i == 0 {
                    self.output.push_str(&format!("    {}\n", injection.name));
                } else {
                    self.output.push_str(&format!("  | {}\n", injection.name));
                }
            }
        } else {
            self.output.push_str("--\n-- A sum type representing one of several possible variants.\n");
            self.output.push_str(&format!("data {} =\n", colimit.name));

            for (i, injection) in colimit.injections.iter().enumerate() {
                let variant_type = self
                    .object_names
                    .get(&injection.source)
                    .cloned()
                    .unwrap_or_else(|| "()".to_string());

                let bang = if self.config.strict_fields { "!" } else { "" };

                if i == 0 {
                    self.output.push_str(&format!("    {} {}{}\n", injection.name, bang, variant_type));
                } else {
                    self.output.push_str(&format!("  | {} {}{}\n", injection.name, bang, variant_type));
                }
            }
        }

        // Deriving clause
        let derives = if is_simple_enum {
            self.format_derives(&["Eq", "Ord", "Show", "Enum", "Bounded"])
        } else {
            self.format_derives(&["Eq", "Show"])
        };

        self.output.push_str(&format!("  deriving stock ({}", derives));

        if self.config.derive_generic {
            self.output.push_str(", Generic");
        }

        self.output.push_str(")\n");

        if self.config.use_aeson {
            self.output.push_str(&format!(
                "\ninstance ToJSON {}\ninstance FromJSON {}\n",
                colimit.name, colimit.name
            ));
        }

        self.output.push_str("\n");

        // Pattern matching helpers
        if !is_simple_enum {
            for injection in &colimit.injections {
                let fn_name = format!("is{}", injection.name);
                self.output.push_str(&format!(
                    r#"-- | Check if value is the '{}' variant.
{} :: {} -> Bool
{} ({} _) = True
{} _ = False

"#,
                    injection.name,
                    fn_name,
                    colimit.name,
                    fn_name,
                    injection.name,
                    fn_name
                ));
            }
        }
    }

    fn write_aggregates(&mut self) {
        let limits: Vec<_> = self
            .context
            .sketch()
            .limits
            .iter()
            .filter(|l| l.is_aggregate)
            .collect();

        if limits.is_empty() || !self.config.generate_validation {
            return;
        }

        self.output.push_str("-- =============================================================\n");
        self.output.push_str("-- Aggregate Validation\n");
        self.output.push_str("-- =============================================================\n\n");

        self.write_validation_error();

        for limit in limits {
            self.write_aggregate_validation(limit);
        }
    }

    fn write_validation_error(&mut self) {
        let derives = self.format_derives(&["Eq", "Show"]);

        self.output.push_str(&format!(
            r#"-- | Error returned when aggregate validation fails.
data ValidationError = ValidationError
  {{ validationInvariant :: !Text
  , validationMessage :: !Text
  }}
  deriving stock ({derives}
"#
        ));

        if self.config.derive_generic {
            self.output.push_str(", Generic");
        }

        self.output.push_str(")\n");

        if self.config.use_aeson {
            self.output.push_str("\ninstance ToJSON ValidationError\ninstance FromJSON ValidationError\n");
        }

        self.output.push_str(&format!(
            r#"
-- | Create a validation error.
mkValidationError :: Text -> Text -> ValidationError
mkValidationError = ValidationError

-- | Result type for validation operations.
type ValidationResult a = Either [ValidationError] a

-- | Create a successful validation result.
validationSuccess :: a -> ValidationResult a
validationSuccess = Right

-- | Create a failed validation result.
validationFailure :: [ValidationError] -> ValidationResult a
validationFailure = Left

"#
        ));
    }

    fn write_aggregate_validation(&mut self, limit: &LimitCone) {
        let root_id = match limit.root {
            Some(id) => id,
            None => return,
        };

        let root_name = self
            .object_names
            .get(&root_id)
            .cloned()
            .unwrap_or_else(|| "Unknown".to_string());

        self.output.push_str(&format!(
            r#"-- | Aggregate: {}
--
-- Root: '{}'

-- | Validate {} aggregate invariants.
--
-- Call this function after making changes to ensure the aggregate
-- is in a valid state.
validate{} :: {} -> ValidationResult {}
validate{} entity =
  let errors = []
      -- TODO: Add invariant validation logic based on model equations
      --
      -- Example invariant:
      -- errors' = if totalPrice entity /= sum (map price (items entity))
      --           then mkValidationError "totalPrice" "totalPrice must equal sum of item prices" : errors
      --           else errors
  in if null errors
     then validationSuccess entity
     else validationFailure errors

-- | Validate and return entity, throwing on failure.
validate{}OrThrow :: {} -> {}
validate{}OrThrow entity =
  case validate{} entity of
    Right e -> e
    Left errs -> error $ "Validation failed: " <> show errs

"#,
            limit.name,
            root_name,
            root_name,
            root_name,
            root_name,
            root_name,
            root_name,
            root_name,
            root_name,
            root_name,
            root_name,
            root_name
        ));
    }

    fn haskell_type_for_target(&self, target: ObjectId) -> String {
        let target_name = self
            .object_names
            .get(&target)
            .cloned()
            .unwrap_or_else(|| "()".to_string());

        if self.entity_ids.contains(&target) {
            format!("{}Id", target_name)
        } else {
            target_name
        }
    }

    fn format_derives(&self, derives: &[&str]) -> String {
        derives.join(", ")
    }
}

/// Convert PascalCase to camelCase.
fn to_camel_case(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_lowercase().collect::<String>() + chars.as_str(),
    }
}

/// Capitalize first letter.
fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_camel_case() {
        assert_eq!(to_camel_case("Customer"), "customer");
        assert_eq!(to_camel_case("OrderId"), "orderId");
    }

    #[test]
    fn test_generate_empty_context() {
        let context = BoundedContext::new("Test");
        let result = generate(&context).unwrap();

        assert!(result.contains("Generated from `Test` bounded context"));
        assert!(result.contains("module Test where"));
        assert!(result.contains("import Data.UUID"));
    }

    #[test]
    fn test_generate_entity() {
        let mut context = BoundedContext::new("Commerce");
        let _customer = context.add_entity("Customer");

        let result = generate(&context).unwrap();

        // Should have newtype ID
        assert!(result.contains("newtype CustomerId = CustomerId"));

        // Should have data type
        assert!(result.contains("data Customer = Customer"));
        assert!(result.contains("customerId :: !CustomerId"));

        // Should have constructor
        assert!(result.contains("createCustomer ::"));
        assert!(result.contains("newCustomerId"));
    }

    #[test]
    fn test_generate_entity_with_morphisms() {
        let mut context = BoundedContext::new("Commerce");
        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");

        context.sketch_mut().graph.add_morphism("placed_by", order, customer);

        let result = generate(&context).unwrap();

        assert!(result.contains("data Order = Order"));
        assert!(result.contains("orderPlaced_by :: !CustomerId"));
    }

    #[test]
    fn test_generate_value_object() {
        let mut context = BoundedContext::new("Commerce");
        let _money = context.add_value_object("Money");

        let result = generate(&context).unwrap();

        assert!(result.contains("-- Value Objects"));
        assert!(result.contains("data Money = Money"));
    }

    #[test]
    fn test_generate_simple_enum() {
        let mut context = BoundedContext::new("Commerce");
        let _status = context.add_enum(
            "OrderStatus",
            vec!["Pending".into(), "Confirmed".into(), "Shipped".into()],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("data OrderStatus ="));
        assert!(result.contains("Pending"));
        assert!(result.contains("| Confirmed"));
        assert!(result.contains("| Shipped"));
        assert!(result.contains("Enum, Bounded"));
    }

    #[test]
    fn test_generate_aggregate() {
        let mut context = BoundedContext::new("Commerce");
        let order = context.add_entity("Order");
        let line_item = context.add_entity("LineItem");

        context.define_aggregate_with_members("OrderAggregate", order, &[line_item]);

        let result = generate(&context).unwrap();

        assert!(result.contains("-- Aggregate Validation"));
        assert!(result.contains("data ValidationError = ValidationError"));
        assert!(result.contains("validateOrder :: Order -> ValidationResult Order"));
        assert!(result.contains("validateOrderOrThrow :: Order -> Order"));
    }

    #[test]
    fn test_generate_sum_type() {
        let mut context = BoundedContext::new("Payments");

        let transaction_id = context.sketch_mut().add_object("TransactionId");
        let error_code = context.sketch_mut().add_object("ErrorCode");

        let _result = context.add_sum_type(
            "PaymentResult",
            vec![
                ("Success".into(), transaction_id),
                ("Failed".into(), error_code),
            ],
        );

        let result = generate(&context).unwrap();

        assert!(result.contains("data PaymentResult ="));
        assert!(result.contains("Success !TransactionId"));
        assert!(result.contains("| Failed !ErrorCode"));
        assert!(result.contains("isSuccess :: PaymentResult -> Bool"));
        assert!(result.contains("isFailed :: PaymentResult -> Bool"));
    }

    #[test]
    fn test_config_no_aeson() {
        let mut context = BoundedContext::new("Test");
        let _customer = context.add_entity("Customer");

        let config = HaskellConfig {
            use_aeson: false,
            ..Default::default()
        };

        let result = generate_with_config(&context, &config).unwrap();

        assert!(!result.contains("import Data.Aeson"));
        assert!(!result.contains("instance ToJSON"));
    }

    #[test]
    fn test_entity_references_use_id_type() {
        let mut context = BoundedContext::new("Commerce");
        let customer = context.add_entity("Customer");
        let order = context.add_entity("Order");

        context.sketch_mut().graph.add_morphism("customer", order, customer);

        let result = generate(&context).unwrap();

        assert!(result.contains("orderCustomer :: !CustomerId"));
    }
}
